# Hash Algorithm

## 해시 알고리즘이란?
 - 해시는 고기와 감자를 잘게 다져서 먹는 음식입니다. 잘게 잘라 원래 모습을 알 수 없듯이, 계산 과정을 거치면서 작아진 값을 말합니다. 해시가 만들어지는 과정은 다음과 같습니다. 데이터(keys)를 해시함수(hash function)에 넣어 return 받는 값이 해시입니다.
 
![](/assets/images/algorithm/hash_1.png)

해시는 검색알고리즘에서 자주사용합니다. 그렇다면 해시함수에 의해 작아진 해시값으로 어떻게 빠른 검색을 할 수 있을까요? 해시 검색의 구조는 다음과 같습니다.

![](/assets/images/algorithm/hash_2.png)

해시 함수의 결과값인 해시 값 자체가 해시테이블의 주소값이 되어 빠른 검색이 가능해집니다. 일반적으로 해시테이블은 주소로 빠로 접근할 수 있는 배열을 사용합니다. 또 테이블은 N개의 버킷으로 구성되어 있는데 버킷이란 해시 테이블에서 자료를 저장하는 단위입니다. 하나의 고유한 해시(주소)에 대응하여 실제 자료가 저장되는 곳입니다.

 ### 계산검색 방법 vs 비교검색 방법
 
 - 계산검색 방법이란?
 해시검색이 대표적인 예인데 해시검색은 해시함수의 결과 값이 곧 주소값이기에 시간복잡도가 최소 O(1)입니다. 자료의 개수 n과 상관없이 특정 상수를 시간내에 계산할 수 있습니다. 이처럼 검색 키에 대해서 주소를 직접 계산하고 검색하는 것입니다.
 
 - 비교검색 방법이란?
 순차검색, B-트리 등이 있습니다. 이러한 알고리즘은 검색 키 값을 하나씩 비교하여 찾아냅니다. 가장 빠른 시간 복잡도는 평균 O(logn)입니다. 비교하는 자료의 수가 많아질 수록 검색 시간이 느려집니다.
 
 ### 해시 테이블에 자료추가하기
 자료를 추가하는 방법은 총 3단계로 이루어져 있습니다. 1. 주소계산 2. 해시테이블 확인 3. 자료 저장입니다. 
 
 ![](/assets/images/algorithm/hash_3.png)
 
 1. 주소계산 : 검색 키를 해시함수를 통해 분해 및 조립을 하여 주소값을 의미하는 해시를 만듭니다.
 
 2. 해시테이블 확인 : 해시를 저장하기 전에 해당 주소에 값이 있는지 확인을 합니다. 
 
 3. 자료 저장 : 자료를 저장할 수 있는 주소를 찾았다면 값을 저장합니다.
 
 #### 해시자체가 주소인데 바로 저장하지 않고 확인하는 이유는 뭘까요?
  이유는 해시함수의 결과에 의해 같은 값이 나오기 때문입니다. 그래서 자신의 주소값에 기존에 있던 값이 존재할 수 있습니다. 이러한 경우를 충돌(collision)이라 합니다.  

 ### 자료검색
 자료검색은 자료 추가 과정에서 자료 저장만 안하면 됩니다. 또 검색은 성능이 좋아야하는데 이를 결정하는 것은 해시함수와 관련이 있습니다.
 
 ![](/assets/images/algorithm/hash_4.png)
 
 ### 해시함수
 좋은 해시함수는 검색을 빠르게 해줍니다. 이를 판단하는 척도로 1. 충돌발생 빈도 2. 해시 테이블 사용률과 3. 해시함수 계산 속도입니다.
 
 1. 충돌발생 빈도 : 충돌발생 시 충돌 처리를 해줘야하므로 최대한 적은 것이 좋습니다.
 2. 해시 테이블 사용률 : 테이블이 고르게 분포되야 저장 공간 활용 효율면에서 좋습니다.
 3. 해시함수 계산 속도 : 빠른 해시함수는 해시검색 속도를 감소시킵니다.
 
 해시함수의 종류로는 1. 나머지함수 2. 접지함수 3. 중간제곱함수 4.숫자분석 기반의 해시함수 등이 있습니다.
 
 1. 나머지함수
 검색키 k를 해시 테이블의 크기 m으로 나눈 나머지를 해시로 사용합니다.
 ~~~
    hash = k % m
 ~~~
 나머지 함수는 테이블의 크기 m이 소수일 수록 충돌 발생 빈도가 낮아집니다. 충돌 발생 빈도가 낮다는 뜻은 해시 테이블 사용률 또한 높아진다는 뜻입니다. 따라서 설계시 해시 테이블이 100이라면 100대신 101을 사용하는 것이 좋습니다.
 
 2. 접지함수
 검색 키를 먼저 분해하고 분해된 부분들을 조합하여 해시를 사용합니다. 보통 검색 키의 크기가 해시 테이블의 크기보다 클 때 사용합니다.(접지라는 이름을 쓰는 이유가 검색 키가 너무 커서 접어서 쓴다 해서 붙여진 이름인거 같습니다.) 접는 방법에 따라 종류가 나뉘는데 대표적인 1.이동접지 함수와 2. 경계접지 함수를 알아보겠습니다.
 
 - 1. 이동접지함수
 분해된 부분들을 오른쪽 정렬을 한 후 각 부분을 조합하는 접지 방법을 말합니다.
 
 ![](/assets/images/algorithm/hash_5.png)
 
 만약 해시값이 m의 값을 넘는다면 초과된 자릿수를 버립니다.
 
 - 2. 경계접지함수
 이동접지함수와 분해, 더하기 부분은 같으나 이동하는 부분이 다릅니다. 경계부분을 반전시켜 값을 더합니다.
 
 ![](/assets/images/algorithm/hash_6.png)
 
3. 중간제곱함수
검색 키의 일부분에서 해시를 채취합니다.
~~~
예) 검색 키 k : 9415
해시 테이블 크기 m : 9999 일때

검색 키의 제곱 : 9451  * 9451 = 89321401, 제곱의 결과의 가운데 4자리가 해시값입니다. 89(3214)01 / 3214 = 해시값
~~~

4. 숫자분석 기반의 해시함수
숫자분석 기반이란 뜻은 검색 키가 어떠한 특징이 있는지 검색 키의 특징을 알아낸다는 뜻입니다. 즉, 이 함수는 충돌이 발생할 가능성이 낮아지도록 검색 키가 가지는 '값의 분포'를 이용한 함수입니다. 예를 들면 학번에서 201331003 중 2013은 입학년도 나머지 5자리는 학과번호와 학생고유번호입니다. 이를 그래프로 그린다면

 ![](/assets/images/algorithm/hash_7.png)
 
입학년도가 같다면 한 곳에 집중되어 충돌 가능성이 높아집니다. 하지만 나머지 5자리로 한다면 고유한 번호이기에 충돌 가능성이 낮아지게 됩니다. 해시함수는 이외에도 진법변환함수, 비트 추출함수, 가상 난수 기법등이 있습니다.
 
 [뒤로](https://github.com/bugkingK/Welcome-My-Github)/[위로](#hash-algorithm)


#### 만약 검색 키가 정수가 아니라 문자열이라면?
지금까지는 검색 키가 정수였습니다. 그렇다면 문자열은 어떻게 처리할까요?
1. 첫 문자 아스키코드 사용
예를들면 검색 키가 ABC일때 A=65 이므로 해시는 65가 됩니다. 첫 글자만 같으면 계속 충돌이 생기므로 효율이 좋지 못합니다.

2. 문자열의 모든 아스키코드 값 더하기
검색 키가 ABC일때 65+66+67 = 198이 해시가 됩니다. 이 또한 검색키가 CBA라면 67+66+65 = 198로 둘의 해시는 충돌하게 됩니다.

3. 문자의 위치를 고려한 코드 값 더하기(허너의 방법)
검색 키가 ABC일때 ((65*31)+66)*31 + 67 = 64578이고 CBA는 ((67*31)66)*31 + 65 = 66498입니다. 둘의 값은 충돌하지 않습니다. 만약 오버플로우가 발생 시 자릿수를 제거함으로써 조치를 취할 수 있습니다.

### 충돌해결
좋은 해시함수로 충돌을 제거하더라도 해시값이 같아 충돌이 나기마련입니다. 이를 해결하는 여러방법이 있지만 2가지 방법을 공부했습니다. 1. 충돌이 일어난 키 값을 비어 있는 다른 주소를 찾아 저장하는 개방주소기법 2. 여러 개의 항목을 저장할 수 있도록 해시 테이블의 구조를 변경하는 체이닝 기법이 있습니다.

1. 개방주소기법
조사법이라고도 불리며 해시함수가 계산한 주소가 비어있는지 확인하고 비어 있다면 값을 저장하고 비어 있지 않다면 빈 주소검색을 합니다. 만약 해시테이블이 꽉 찬경우는 중지합니다. 빈 주소를 검색하는 방법으론 1) 선형조사법 2) 제곱조사법 3) 이중해싱 등이 있습니다.

- 1) 선형조사법
충돌이 발생할 경우 주소를 일정한 상수만큼 증가시켜 다시 조사합니다. 충돌 위치와 근접해 있다보니 다음 충돌 또한 근처에 발생할 수 밖에 없어 클러스트(군집화)현상이 발생하기 쉽습니다.
~~~
h(k) = (k + try_count) mod m
~~~

- 2) 제곱조사법
충돌이 발생할 경우 주소를 조사 횟수의 제곱만큼 증가시켜 다시 조사하는 방법입니다. 1차 충돌은 1을 더하고 2차 충돌은 4(2*2) n차 충돌은 n^2을 더합니다.
~~~
h(k) = (k + try_count * try_count) mod m
~~~
선형조사법에 비해 군집화 현상 발생 가능성이 낮으나 가능성은 있습니다. 또 해시테이블의 모든 주소를 조사하려면 해시 테이블의 크기가 반드시 소수여야 하는 제약도 있습니다.

- 3) 이중 해시
충돌 발생 시 원래의 해시함수 말고 다른 해시함수를 이용해 조사합니다. 어떤 해시함수에 따라 기법이 달라지는데 그 중 조사간격 기법은 다음과 같습니다.
~~~
(조사 간격) = m - (k mod m)
~~~
이중해싱은 추가 해시함수로 같은 해시값을 가지더라도 조사 순서를 달리하여 군집화 발생가능성을 낮췄습니다.


2. 체이닝 기법
해시 테이블의 각 버킷에 하나 이상의 검색 키를 저장하는 방법입니다. 체이닝은 각 주소에 연결리스트를 사용하여 충돌이 발생할 때 동적으로 여러 개의 검색 키 값을 저장할 수 있게합니다.

 ![](/assets/images/algorithm/hash_8.png)
 
기존 해시테이블에 값을 저장했다면 그 값 대신 연결리스트의 주소값을 넣어줍니다.

 ![](/assets/images/algorithm/hash_9.png)
 
해시함수의 결과 같은 주소값이 나왔을 때 해당 값을 연결리스트에 추가해줌으로 충돌을 해결합니다. 해시를 저장하는 방법은 인덱스 0부터 추가하거나 마지막 부터 추가합니다. 또 오름차순, 내림차순으로 추가하는 등 여러 방법이 있습니다.

 [뒤로](https://github.com/bugkingK/Welcome-My-Github)/[위로](#hash-algorithm)
